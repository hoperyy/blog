[issue](https://api.github.com/repos/hoperyy/blog/issues/108)

# 前端性能优化
## 性能优化体系

+	性能优化指标：PageLoad、FPS、内存……
+	性能优化实施
	+	理论 + 文档
	+	最佳实践
	+	优化好的组件
	+	工具支撑
	+	系统支撑
+	性能优化评测
+	各业务性能数据结果
+	性能优化效果-业务价值

## 性能优化方法

### 加载性能

+	加载性能指标

	H5 的加载性能指标：秒开率不低于 70%

	秒开率：指所有网络（wifi、4G、3G、2G）下的加载时间小于 1s 的占比

+	利用工具分析用户加载性能

	比如 TB 有一个平台，输入页面地址后，可以给出 50 个样本数据，并提供每个样本的瀑布流截屏，以便分析。

+	加载性能知识点
	
	+	httpDNS

		+	httpDNS 是什么

			httpDNS 是面向无线端的域名解析服务，与传统的走 UDP 协议的 DNS 不同，httpDNS 基于 HTTP 协议。

			PC 端的服务一般通过浏览器访问，对于域名解析，浏览器只会走标准 DNS，我们没法干预。无线端的可操作空间比较大，APP 可以自己构造并发送 HTTP 请求，所以能够做到精细化的控制，其中就包括域名解析。

			使用 httpDNS 解析域名的基本流程如下：

			1、客户端向 httpDNS 服务端发送普通的 HTTP 请求，请求中携带需要解析的域名。

			2、httpDNS 服务端解析出域名对应的 ip 地址，将解析结果封装为 JSON 格式，返回给客户端。

			和传统 DNS 一样，httpDNS 的解析结果中包含 TTL，客户端可以根据 TTL 将结果缓存一段时间。

		+	httpDNS 的优势

			+	防止域名劫持

				传统 DNS 由 Local DNS 解析域名，不同运营商的 Local DNS 由不同的策略，某些 Local DNS 可能会劫持特定的域名，

				采用 httpDNS 可以绕过 Local DNS，避免被劫持；

				另外，httpDNS 的解析结果包含 HMAC 校验，也能够防止解析结果被中间网络设备篡改。

			+	更精准的调度

				对域名解析而言，尤其是 CDN 域名，解析得到的 IP 应该更靠近客户端的地区和运营商，这样才能有更快的网络访问速度。然而，由于运营商策略的多样性，其推送的 Local DNS 可能和客户端不在同一个地区，这时得到的解析结果可能不是最优的。httpDNS 能够得到客户端的出口网关 IP，从而能够更精确地判断客户端的地区和运营商，得到更精准的解析结果。

			+	更小的解析延迟和波动

				在 2G/3G 这种移动网络下，DNS 解析的延迟和波动都比较大。就单次解析请求而言，httpDNS 不会比传统的 DNS 更快，但通过 httpDNS 客户端 SDK 的配合，总体而言，能够显著降低解析延迟和波动。httpDNS 客户端 SDK 有几个特性：预解析、多域名解析、TTL 缓存和异步请求。

			+	额外的域名相关信息

				传统 DNS 的解析结果只有 ip，httpDNS 的解析结果采用 JSON 格式，除了 ip 外，还支持其他域名相关的信息，比如端口、spdy 协议等。利用这些额外的信息，APP 可以启用或停止某个功能，甚至利用 httpDNS 来做灰度发布，通过 httpDNS 控制灰度的比例。

		+	httpDNS 如何解析一个域名

			httpDNS 服务端并没有“域名和 ip 对应关系”的数据库，它做了一次协议转换，从 HTTP 转换为 DNS，将域名解析请求转发给后端 DNS。

			请求过程是这样的：客户端--（HTTP）-- httpDNS 服务器 --（DNS）-- DNS服务器

			后端 DNS 服务器需要拿到客户端的来源 ip，如何透传 httpDNS 服务器呢？httpDNS 使用了 Google 提出的 DNS 扩展选项 edns-client-subnet，通过该选项，可以将客户端 ip 放在 DNS 报文中传给后端 DNS，只要后端 DNS 支持该选项，它就会从 DNS 报文中提取客户端 ip。 httpDNS 对接的后端 DNS 都支持 edns-client-sub 选项。

			具体而言，httpDNS 服务端的处理过程如下：

			1、接收客户端发来的 HTTP 请求，请求中携带域名列表。

			2、解析请求的内容，检查安全校验值，执行白名单过滤，得到待解析的域名列表。

			3、针对域名列表中的每一个域名，构造 DNS 请求报文，发往对应的后端 DNS。

			4、等待并收集 DNS 响应报文，解析报文得到 IP 地址，最后，每个域名都有了解析结果或已经超时。

			5、对每个域名，将解析得到的 IP，以及在 httpDNS 上配置的其他信息，添加到 JSON 报文中。

			6、根据 JSON 报文计算 HMAC 校验值，将校验值和 JSON 报文发给客户端。

	+	spdy & SSL

		提供 SPDY 协议的底层支持，从而完成多路复用的加密全双工通道，显著提升非 wifi 环境下的网络体验。

		优势：

		1、多路复用请求优化

		2、服务器推送技术

		3、SPDY 压缩 http 头

	+	webp

		webp 是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。根据 Google 官方的数据，无损压缩后的 webp 比 PNG 文件少了 26% 的文件大小，有损压缩在具有同等 SSIM 索引的情况下 webp 比 jpeg 文件少 25~34% 的文件大小。webp 支持无损透明度（也叫作 alpha 通道），图片大小增加 22%。支持动画格式 Animated WebP。

	+	iconfont

		iconfont 对于前端来说有很多优点：自由变化大小、矢量不失真、自由修改颜色、可以添加一些视觉效果如阴影、旋转、透明度、兼容 IE6.

		为了节省流量，在移动端，目前只引用 ttf 一个字体文件，可以考虑 base64 在 css 文件中。

	+	sprite 图片

		+	解码内存消耗

			内存消耗公式：w * h * 4（宽 * 高 * 每个像素 4 个字节）

			如果设备 DPI 大于 1，还需要乘以 DIP 系数，如 Retina 设备 X4，RetinaHD 设备 X8

		+	禁止生成大图且利用率少

	+	商品图片

		+	图片质量

			根据网络的不同，可以显示不同质量的商品图片。

		+	图片锐化

		+	不必要的浪费

			合理地使用 CDN 图片尺寸可以带来下载图片的性能提升，还可以减少不必要的内存消耗。举例：

			自然尺寸：110\*110
			显示尺寸：100\*100
			不必要的像素：110\*110 - 100\*100 = 2100
			不必要的内存消耗：2100\*4/1024=8.2kb
			2X: \*4=32.8kb
			3X: \*9=73.8kb

	+	mtop

		+	服务能力

			在云端支持 HSF、HTTP 等多种服务的接入，并通过 mtop 的管理平台支持，API 的动态接入，支持多种缓存策略、支持断点续传。

		+	安全体系

			网关本身包含了一套安全体系，包括加密传输、防攻击、防刷、防篡改、过载保护等安全策略。

		+	网络优化

			同时针对无线网络的特点，在连通性、网络加速、流量方面进行了针对性优化。

		+	运维工具


### 渲染性能 for web

+	前言

	用户都希望他们访问的 web 应用是可交互且运行流畅的。

	因此，作为 web 开发者，也需要多花点功夫。

	页面不但要能被快速加载，还要能流畅运行：页面的滚动要快速响应手指的动作，动画和交互效果更要如丝般顺滑。

	+	60 fps 和 设备刷新率

		如今大部分设备的屏幕刷新率都是 60 次/秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滑动页面，那么浏览器渲染动画或页面的每一帧的速率，也需要和设备屏幕的刷新率保持一致。

		也就是说，浏览器对每一帧画面的渲染工作需要在 16 毫秒内完成。但实际上，在渲染某一帧画面的同事，浏览器还有一些额外的工作要做（比如渲染队列的管理，渲染线程与其他线程之间的切换等等）。因此单纯的渲染工作一般需要控制在 10 毫秒之内完成，才能达到流畅的视觉效果。如果超过了这个时间限度，页面的渲染就会出现卡顿，也就是常说的 jank。

	+	像素渲染流水线

		+	JavaScript -- Style -- Layout -- Paint -- Composite

		+	JavaScript -- Style -- （Layout） -- Paint -- Composite

			如果修改了一个 DOM 元素的 `paint only` 属性，比如背景图片、文字颜色或阴影等，这些属性不会影响页面的布局，因此浏览器会在完成样式计算之后，跳过布局过程，只做绘制渲染层合并过程。

		+	JavaScript -- Style -- （Layout -- Paint） -- Composite

			如果修改一个非样式且非绘制的 css 属性，那么浏览器会在完成样式计算后，跳过布局和绘制的过程，直接做渲染层合并，

			这种方式在性能上是最理想的，对于动画和滚动这种负荷很重的渲染，我们要争取使用这种渲染流程。

+	如何排查渲染性能问题

	首先使用 chrome 的 timeline。

	帧率区域上边标红的区域，都是有问题的帧。需要重点关注帧率低和标红的地方。

	+	JavaScript 分析

		JavaScript Profiler 选项打开。

	+	render 分析

		render 部分包括 Recalculate Style 和 Layout。可以从这两方面分析。如果某一帧触发了强制 Layout，timeline 会用红色角标标出，这是需要优化的地方。

	+	Paint 分析

		可以选中 timeline 中绿色的 paint 部分。

		summary 会展示绘制的总体情况，包括绘制的元素、元素本身绘制耗时、元素子元素绘制耗时。

		如果发现绘制的区域超过了本来期望的区域，那么就是需要优化的。

		更加详细的信息，可以切换到 paint profiler。

+	页面的构建过程。

	+	HTML -- Nodes

		一一对应

	+	Nodes -- LayoutObjects

		一一对应

	+	LayoutObjects 到 PaintLayers

		满足以下条件的 LayoutObjects 会拥有独立的渲染层，而其他的 LayoutObject 则和其第一个拥有渲染层的父元素共用一个。

		+	NormalPaintLayer（被认为是 SelfPaintingLayer）
			+	根元素（HTML）
			+	有明确的定位属性（relative、fixed、sticky、absolute）
			+	透明的（opacity 小于 1）
			+	有 css 滤镜（filter）
			+	有 css mask 属性
			+	有 css mix-blend-mode 属性（不为 normal）
			+	有 css transform 属性（不为 none）
			+	backface-visibility 属性为 hidden
			+	有 css reflection 属性
			+	有 css column-count 属性（不为 auto）或者有 css column-width 属性（不为 auto）
			+	当前有对于 opacity、transform、filter、backdrop-filter 应用动画
		+	OverflowClipPaintLayer
			+	overflow 不为 visible
		+	NoPaintLayer
			+	不需要 paint 的 PaintLayer，比如一个没有视觉属性（背景、颜色、阴影等）的空 div

	+	PaintLayers 到 GraphicLayers（合成层）

		渲染层提升为合成层有一个先决条件，该渲染层必须是 SelfPainingLayer，同时满足以下条件的会被提升为合成层:

		+	直接原因

			+	硬件加速的 iframe 元素（比如 iframe 嵌入的页面中有合成层）
			+	html5 video 元素
			+	覆盖在 video 元素上的视频控制栏
			+	3D 或者硬件加速的 2D canvas 元素
			+	硬件加速的插件，比如 flash 等
			+	在 DPI 较高的屏幕上，fix 定位的元素会自动地被提升到合成层中。但在 DPI 较低的设备上并非如此，因为这个渲染层的提升会使得字体渲染方式变为灰阶。
			+	有 3D transform
			+	backface-visibility 为 hidden
			+	对 opacity、transform、filter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition。当 animation 或 transition 效果未开始或结束后，提升合成层也会失效）
			+	will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）

		+	后代原因

			+	有合成层后代同时本身有 transform、opacity（小于 1）、mask、filter、relfelction 属性
			+	有合成层后代同时本身 overflow 不为 visible
			+	有合成层后代同时本身 fixed 定位
			+	有 3D transform 的合成层后代同时本身有 preserve-3d 属性
			+	有 3D transform 的合成层后代同时本身有 perspective 属性

		+	overlap 重叠原因

	+	层压缩

		由于重叠的原因，可能随便就能产生大量的合成层，而每个合成层要消耗 CPU 和内存。浏览器考虑到了，于是有了层压缩。但不是万能的，有很多情况下，浏览器是无法进行层压缩的。这些也是我们应该避免的。

	+	提升为合成层有以下好处：

		+	合成层的位图，会交由 GPU 合成，比 CPU 处理要快。

		+	当需要 repaint 时，只需要 repaint 本身，不会影响到其他层。

		+	对于 transform 和 opacity 效果，不会触发 layout 和 paint。

		+	对于 fixed 的合成层，移动时不会触发 repaint。


+	Script 优化

	错误的执行时机和太长的时间消耗，是常见的导致 js 性能低下的原因。尽量从这两方面对 js 代码带来的执行性能的影响入手。

	+	实现动画效果，避免使用 setTimeout 或 setInterval，请使用 requestAnimationFrame

	+	降低代码复杂度或把耗时长的 js 代码放到 Web Workers 去做

	+	把 DOM 元素的更新划分为多个小任务，分别在多个 frame 中去完成

	+	使用 timeline 和 js profiler 分析性能

	+	避免对 js 进行微优化

+	Style 优化
	
	+	降低样式选择器的复杂度；使用基于 class 的方式，比如 BEM。

	+	减少需要执行样式计算的元素个数。

	如果在 timeline 里看到了运行时间过长的帧，就要好好分析一下了。

+	Layout 优化

	+	触发条件

		+	DOM 元素的“几何属性”的修改

			比如 width/height/left/top 等，都需要重新计算布局

		+	读取样式属性，强制同步布局

			如果在读取样式属性之前，修改了容器的样式，那么会强制触发重绘。

		如果无法避免布局的发生，那么，应该使用 timeline 分析页面数据，

	+	优化方案

		+	减少需要 Layout 的 DOM 元素数量

		+	使用 flexbox 替代老的布局模型

			flexbox 的性能更高

		+	避免强制同步布局事件的发生

			我们可以强制浏览器在执行 js 脚本之前先执行布局过程，这就是所谓的强制同步布局。

			在 js 运行的时候，它能获取到的元素样式属性值都是上一帧画面的，都是旧值。

			如果在读取 height 属性之前，修改了容器的样式，那么会强制触发重绘。

			```
			box.classList.addClass('big');
			console.log(box.offsetHeight);
			```

			为了避免触发不必要的布局过程，应该首先批量读取元素样式属性（浏览器将直接返回上一帧的样式属性值），然后再对样式属性进行写操作。
			
			```
			console.log(box.offsetHeight);
			box.classList.addClass('big');
			```

		+	避免快速连续的布局

			这种情况更糟糕，看代码：

			```
			for(var i = 0; i < sub.length; i++) {
				sub[i].style.width = box.offsetWidth + 'px';
			}
			```

			在下一次循环中读取 box 的属性值时，浏览器必须先使上一次循环中的样式更新操作生效，也就是执行布局过程，然后才能响应本次循环中的样式读取操作，也就意味着，布局过程将在每次循环中发生。

			优化：

			```
			var width = box.offsetWidth;
			for(var i = 0; i < sub.length; i++) {
				sub[i].style.width = width + 'px';
			}
			```

+	Paint 优化

	Paint（绘制）其实是生成元素呈现的像素的过程。例如，一个有着灰色背景、有文字的元素，当浏览器 Paint 时，是决定哪些像素填充背景、哪些像素填充文字，然后浏览器将这些像素存入位图（Bitmap）中。

	Paint 是代价最高的一步，因此尽量减少 Paint 的时间，甚至避免 Paint 的发生，对页面性能的提升有很重要的作用。

	+	如何定位

		chrome 的 DevTools，勾选 Enable Paint Flashing.

		页面的绿色方框就是 Paint 的区域。

		结合 timeline 对闪动的区域查看更详细的记录。

	+	如何触发

		+	触发 Layout。如几何属性的修改。
		+	改变非几何属性，如：背景、颜色、阴影等，不会触发 Layout，但会触发 Paint。（csstriggers.com）

	+	如何优化

		+	提升元素渲染层为合成层。

			需要注意的是，用 transform 和 opacity 时，如果元素被提升到了独立的合成层，不会触发 Paint；但如果没有提升，还是会触发。

+	Composite 优化

	+	用合成层做动画

		优先：will-change

		其次：transform：translateZ(0);

	+	用 transform 或 opacity 实现动画

		他们仅触发 composite。前提是元素提升为 合成层。

	+	减少绘制区域

	+	防止层爆炸

		解决方案是打破 overlap 的条件，也就是让其他元素不要和合成层元素层叠。

		z-index

### 感知性能

+	白屏感知
	+	页面可见时间
	+	重要内容可见时间
	+	白屏时间和补救方法
		尽量同步输出，mock，placeholder
	+	首屏加载完成时间

+	流畅感知

### 内存

### chrash

### 全链路监控

### 性能探索

+	webp 与 base64

	+	webp 解码是由 GPU 完成，会增加解码开销，但没有太大影响，应该优先使用
	+	DataUrl 解码是在主进程进行的。 会大幅增加图片解码的开销，增加对 CPU 和 内存的开销，甚至阻塞浏览器的主进程，造成卡顿，只有图片的体积足够小，而且是静态的，不值得消耗一个请求的时候，才应该使用 DataUrl。

+	图片大小对内存的影响

	+	加载、显示、隐藏、移除
	+	真正耗费内存的是图片的解析过程
	+	隐藏图片节点可以减少内存消耗，但作用不大
	+	移除图片节点不会直接减少内存消耗
	+	图片显示尺寸直接影响内存，显示越大占用内存越多。
	+	同一个页面中完全相同的图片会共享内存。
