这是很考知识面的一个问题，这里稍微总结一下，顺便谈一下各个阶段性能优化的地方。

##	用户在浏览器地址栏敲入了网址

浏览器可能很智能地进行了预解析

##	浏览器查找域名的 IP 地址（DNS 解析）

+	1、查找浏览器缓存

	浏览器会查找浏览器缓存中该域名有没有解析过的 IP 地址，如果缓存中有，这个过程就结束。

	浏览器缓存域名也是有限制的，包括缓存大小和缓存时间。

	缓存时间通常为几分钟到几个小时不等。

+	2、查找系统缓存

	其实操作系统也有一个域名解析的过程，也就是我们有时会在 hosts 文件里绑定一些域名和 IP 见到的那样。

	正是有这样的解析过程，黑客就有可能修改你的域名解析来把特定的域名解析到它指定的 IP 上。

+	3、查找路由器缓存

	如果系统缓存也找不到，那么查询请求会发向路由器，它一般会有自己的缓存。

+	4、查找 ISP DNS 缓存

	如果运气实在不好，那就只能查询 ISP DNS 缓存服务器了。在我们的网络配置中都会有"DNS 服务器地址"这一项，操作系统会把这个域名发送给这里设置的 DNS，也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约80%的域名解析都到这里就已经完成了，所以 ISP DNS 主要承担了域名的解析工作。

+	5、递归搜索

	最无奈的情况发生了, 在前面都没有办法命中的DNS缓存的情况下,

	(1) 本地 DNS 服务器即将该请求转发到互联网上的根域（即一个完整域名最后面的那个点，通常省略不写）。

	(2) 根域将所要查询域名中的顶级域（假设要查询 ke.qq.com，该域名的顶级域就是 com）的服务器 IP 地址返回到本地 DNS。

	(3) 本地 DNS 根据返回的 IP 地址，再向顶级域（就是 com 域）发送请求。

	(4) com 域服务器再将域名中的二级域（即 ke.qq.com中的qq ）的 IP 地址返回给本地 DNS。

	(5) 本地 DNS 再向二级域发送请求进行查询。

	(6) 之后不断重复这样的过程，直到本地 DNS 服务器得到最终的查询结果，并返回到主机。这时候主机才能通过域名访问该网站。

### DNS 的性能优化

+	减少主机域名的数量

+	DNS 预解析

	+	通过 `<meta>` 标签告诉浏览器要进行域名预解析

		`<meta http-equiv="x-dns-prefetch-control" content="on" />`

	+	可以用 link 标签来强制 DNS 做预解析

		`<link rel="dns-prefetch" href="http://www.taobao.com" />`

+	缓存

	+	浏览器 DNS 记录的数量是有限制的，如果短时间内访问了大量的域名，那么之前存储的域名缓存会被删除，但操作系统的 DNS 缓存还是可能存储记录的，这样就可以避免通过网络查询带来的延迟。

	+	减少 DNS 查找，避免重定向。配置 EXPIRES 头、Cache-Control、ETAG

		+	ETAG

			浏览器发送页面请求时，将上次服务器响应回的 ETAG 一并发送到服务器，服务器检查 ETAG，如果发现该页面自上次客户端请求之后还未被修改，直接返回响应 304（未修改 -- Not Modified）和一个空的响应体。

		+	Expires(HTTP/1.0)

			过期头。设置为标准时间，标准时间内，浏览器读取缓存；超过了标准时间，浏览器请求服务器资源。

			但这种方案有缺点：要求服务器时间和客户端时间严格同步；并且过期时间需要经常检查，并且这一天一旦到来，还要在服务器提供一个新的日期。

			如果在缓存时间内，服务器返回 304

		+	Cache-Control(HTTP/1.1)

			使用 max-age 指令控制资源被缓存多久。

			如果在缓存时间内，服务器返回 304


+	httpDNS

	+	httpDNS 是什么

		httpDNS 是面向无线端的域名解析服务，与传统的走 UDP 协议的 DNS 不同，httpDNS 基于 HTTP 协议。

		PC 端的服务一般通过浏览器访问，对于域名解析，浏览器只会走标准 DNS，我们没法干预。无线端的可操作空间比较大，APP 可以自己构造并发送 HTTP 请求，所以能够做到精细化的控制，其中就包括域名解析。

		使用 httpDNS 解析域名的基本流程如下：

		1、客户端向 httpDNS 服务端发送普通的 HTTP 请求，请求中携带需要解析的域名。

		2、httpDNS 服务端解析出域名对应的 ip 地址，将解析结果封装为 JSON 格式，返回给客户端。

		和传统 DNS 一样，httpDNS 的解析结果中包含 TTL，客户端可以根据 TTL 将结果缓存一段时间。

	+	httpDNS 的优势

		+	防止域名劫持

			传统 DNS 由 Local DNS 解析域名，不同运营商的 Local DNS 由不同的策略，某些 Local DNS 可能会劫持特定的域名，

			采用 httpDNS 可以绕过 Local DNS，避免被劫持；

			另外，httpDNS 的解析结果包含 HMAC 校验，也能够防止解析结果被中间网络设备篡改。

		+	更精准的调度

			对域名解析而言，尤其是 CDN 域名，解析得到的 IP 应该更靠近客户端的地区和运营商，这样才能有更快的网络访问速度。然而，由于运营商策略的多样性，其推送的 Local DNS 可能和客户端不在同一个地区，这时得到的解析结果可能不是最优的。httpDNS 能够得到客户端的出口网关 IP，从而能够更精确地判断客户端的地区和运营商，得到更精准的解析结果。

		+	更小的解析延迟和波动

			在 2G/3G 这种移动网络下，DNS 解析的延迟和波动都比较大。就单次解析请求而言，httpDNS 不会比传统的 DNS 更快，但通过 httpDNS 客户端 SDK 的配合，总体而言，能够显著降低解析延迟和波动。httpDNS 客户端 SDK 有几个特性：预解析、多域名解析、TTL 缓存和异步请求。

		+	额外的域名相关信息

			传统 DNS 的解析结果只有 ip，httpDNS 的解析结果采用 JSON 格式，除了 ip 外，还支持其他域名相关的信息，比如端口、spdy 协议等。利用这些额外的信息，APP 可以启用或停止某个功能，甚至利用 httpDNS 来做灰度发布，通过 httpDNS 控制灰度的比例。

	+	httpDNS 如何解析一个域名

		httpDNS 服务端并没有“域名和 ip 对应关系”的数据库，它做了一次协议转换，从 HTTP 转换为 DNS，将域名解析请求转发给后端 DNS。

		请求过程是这样的：客户端--（HTTP）-- httpDNS 服务器 --（DNS）-- DNS服务器

		后端 DNS 服务器需要拿到客户端的来源 ip，如何透传 httpDNS 服务器呢？httpDNS 使用了 Google 提出的 DNS 扩展选项 edns-client-subnet，通过该选项，可以将客户端 ip 放在 DNS 报文中传给后端 DNS，只要后端 DNS 支持该选项，它就会从 DNS 报文中提取客户端 ip。 httpDNS 对接的后端 DNS 都支持 edns-client-sub 选项。

		具体而言，httpDNS 服务端的处理过程如下：

		1、接收客户端发来的 HTTP 请求，请求中携带域名列表。

		2、解析请求的内容，检查安全校验值，执行白名单过滤，得到待解析的域名列表。

		3、针对域名列表中的每一个域名，构造 DNS 请求报文，发往对应的后端 DNS。

		4、等待并收集 DNS 响应报文，解析报文得到 IP 地址，最后，每个域名都有了解析结果或已经超时。

		5、对每个域名，将解析得到的 IP，以及在 httpDNS 上配置的其他信息，添加到 JSON 报文中。

		6、根据 JSON 报文计算 HMAC 校验值，将校验值和 JSON 报文发给客户端。


##	找到 IP 地址后，浏览器向 web 服务器发送 HTTP 请求

浏览器和服务器建立 TCP 连接

### 性能优化
	
+	浏览器连接数限制

	浏览器对同一个域名的并发请求数量是有限制的，如果是图片这样的资源，可以生成多种域名，这样就可以避开同域名并发请求数量的限制。

+	控制发送 cookie

	同时，同域名的链接请求会携带 cookie，如果某些服务不需要 cookie，就要屏蔽它们，比如图片资源的获取，可以将图片的地址和页面主域名区分开来。

+	减少请求数量

	+	CSS sprites

		可以使用自动化工具生成 sprites

	+	按需加载

	+	合并脚本和样式表

		这里涉及到资源版本缓存与更新，静态资源可以通过以下方式渲染到页面：

		+	基于时间戳的静态资源识别

			这种方式的缺点是：如果其中某个资源更新了，经过发布系统，其他未修改的文件时间戳改变，会使浏览器重新请求资源，缓存失效。

		+	基于文件内容修改的静态资源识别

			用这种方式的话，多个静态文件中某个文件更新后，就会只更新该文件的 md5。

			因为每个 md5 只针对该修改，故可以永久缓存该资源。如果文件有更新，就相当于一个新资源了。

		+	combo

			combo 现在已经大规模用于大型网站系统。

			这种方式的缺点是：多个资源 combo 为一个后，如果其中一个修改，会引起整个 combo 文件的更新，增加带宽开销。

			解决方案：

			combo 服务器就要做点工作了，服务器会检查站点的页面对静态资源的请求情况，如果发现 A 页面使用了 `??a,b,c,d`，B 页面使用了 `??a,b,e,f`，服务器会聪明地将 `a,b` combo 为一个资源 `??a,b`，单后单独处理 `??c,d` 和 `??e,f`。 这样 `??a,b` 就被缓存下来，访问 A 页面后，B 页面就能使用缓存过的 `??a,b` 了。

			这样，虽然增加了连接数，但是大大节约了带宽。基于 HTTP/2 的大规模应用，连接数增加不再是大问题。

			同时，服务器不断地根据统计情况，对静态资源的配置动态优化。

+	减少请求带宽
	+	开启 GZIP
	+	精简 JS
	+	移除重复脚本
	+	图像优化

+	缓存利用

	+	使用 CDN
	+	使 ajax 可缓存

		说来这个很少遇到过。

	+	添加 expires 头、配置 etag，减少 DNS 查找

+	SPDY + HTTPS
+	HTTP/2

##	服务器接收请求，处理，并返回响应

过程如题

### 性能优化

+	使用 GZIP 和 缓存头
+	EXPIRES 头
+	ETAG
+	Cache-Control

##	浏览器处理响应
+	可能关闭该 TCP 连接
+	可能继续利用这个 TCP 通道，发送新请求
+	浏览器根据响应类型决定如何处理

	如 HTML、image 等

+	浏览器可能缓存该响应
+	解码如果响应是压缩的话
+	浏览器会根据不同的响应状态，做出不同的选择：
	+	重定向（3xx）
	+	验证（401）
	+	错误信息（4xx 和 5xx）
	+	……

	这些状态和 2xx 的状态处理方式是不同的

## 浏览器渲染

这一块能说的还是很多的，比如加载性能、渲染性能、感知性能、Crash 等，每一块都是很多细节。

+	尽早刷新文档的输出

+	页面结构
	
	+	将样式表放在顶部
	+	将脚本放在底部
	+	尽早刷新文档的输出

+	代码校验

	+	避免 CSS 表达式
	+	避免重定向
